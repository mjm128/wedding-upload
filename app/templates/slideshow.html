<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Live Slideshow</title>
    <link rel="stylesheet" href="/static/style.css">
    <style>
        body { overflow: hidden; background-color: #000; }
        .slideshow-container {
            width: 100vw;
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }
        .slide {
            position: absolute;
            max-width: 100%;
            max-height: 100%;
            opacity: 0;
            transition: opacity 1s ease-in-out;
        }
        .slide.active { opacity: 1; }
        .caption-overlay {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 8px;
            color: #fff;
            font-family: var(--header-font);
        }
    </style>
</head>
<body>
    <div id="banner" class="sticky-banner"></div>

    <div class="slideshow-container" id="container">
        <!-- Slides -->
    </div>

    <script>
        // Very basic slideshow logic:
        // 1. Fetch feed.
        // 2. Cycle through items.
        // 3. Refetch when near end or periodically.

        let queue = [];
        let cursor = null;
        let currentIndex = -1;
        let container = document.getElementById('container');

        async function fetchMedia() {
            let url = '/slideshow/feed?limit=20';
            if (cursor) url += '&cursor=' + cursor;

            try {
                const res = await fetch(url);
                const data = await res.json();
                if (data.items.length > 0) {
                    // Preload images?
                    data.items.forEach(item => {
                        // Avoid dups if possible, but simpler to just push
                        queue.push(item);
                    });
                    cursor = data.next_cursor; // Wait, API returns oldest as next cursor for pagination...
                    // Actually for a slideshow we want "NEWEST" or "RANDOM" or just cycle all?
                    // Typically a wedding slideshow cycles *all* approved media.
                    // If we want "live", we should poll for *newer* than latest we have.
                    // Let's adjust logic:
                    // Just poll /slideshow/feed without cursor to get latest, or with cursor to get older?
                    // Let's assume the API returns *latest* first.
                }
            } catch (e) { console.error(e); }
        }

        // Let's change strategy: Load *all* (or last 100) and cycle. Then poll for new ones.
        // The API returns limit 20.

        async function loadInitial() {
            const res = await fetch('/slideshow/feed?limit=50');
            const data = await res.json();
            queue = data.items;
            nextSlide();
        }

        function nextSlide() {
            if (queue.length === 0) {
                setTimeout(loadInitial, 2000);
                return;
            }

            currentIndex = (currentIndex + 1) % queue.length;
            const item = queue[currentIndex];

            // Create Element
            const el = document.createElement(item.type === 'video' ? 'video' : 'img');
            el.src = item.url;
            el.className = 'slide';
            if (item.type === 'video') {
                el.muted = true;
                el.autoplay = true;
                el.loop = true; // Loop video for duration of slide? Or play once?
                // If play once, we need to listen for 'ended'
            }

            // Clear container
            container.innerHTML = '';
            container.appendChild(el);

            // Caption
            if (item.caption || item.author) {
                const cap = document.createElement('div');
                cap.className = 'caption-overlay';
                cap.innerHTML = `<strong>${item.author || 'Guest'}</strong><br>${item.caption || ''}`;
                container.appendChild(cap);
            }

            // Trigger Fade In
            setTimeout(() => el.classList.add('active'), 50);

            // Schedule next
            let duration = 5000;
            if (item.type === 'video') {
                 // Try to guess duration or default
                 duration = 10000;
                 el.onloadedmetadata = () => {
                     if (el.duration) duration = el.duration * 1000;
                 };
                 el.onended = nextSlide;
            } else {
                setTimeout(nextSlide, duration);
            }
        }

        // Poll for new config/banner
        setInterval(() => {
             fetch('/config').then(r => r.json()).then(config => {
                if (config.banner_message) {
                    const b = document.getElementById('banner');
                    b.innerText = config.banner_message;
                    b.style.display = 'block';
                } else {
                    document.getElementById('banner').style.display = 'none';
                }

                // Also poll for new images to add to queue?
                // Complex without a "since" timestamp.
            });
        }, 30000);

        loadInitial();
    </script>
</body>
</html>
